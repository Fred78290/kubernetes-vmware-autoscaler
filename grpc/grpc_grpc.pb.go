// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: grpc.proto

package grpccloudprovider

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	CloudProviderService_Connect_FullMethodName                  = "/grpccloudprovider.CloudProviderService/Connect"
	CloudProviderService_Name_FullMethodName                     = "/grpccloudprovider.CloudProviderService/Name"
	CloudProviderService_NodeGroups_FullMethodName               = "/grpccloudprovider.CloudProviderService/NodeGroups"
	CloudProviderService_NodeGroupForNode_FullMethodName         = "/grpccloudprovider.CloudProviderService/NodeGroupForNode"
	CloudProviderService_Pricing_FullMethodName                  = "/grpccloudprovider.CloudProviderService/Pricing"
	CloudProviderService_GetAvailableMachineTypes_FullMethodName = "/grpccloudprovider.CloudProviderService/GetAvailableMachineTypes"
	CloudProviderService_NewNodeGroup_FullMethodName             = "/grpccloudprovider.CloudProviderService/NewNodeGroup"
	CloudProviderService_GetResourceLimiter_FullMethodName       = "/grpccloudprovider.CloudProviderService/GetResourceLimiter"
	CloudProviderService_GPULabel_FullMethodName                 = "/grpccloudprovider.CloudProviderService/GPULabel"
	CloudProviderService_GetAvailableGPUTypes_FullMethodName     = "/grpccloudprovider.CloudProviderService/GetAvailableGPUTypes"
	CloudProviderService_Cleanup_FullMethodName                  = "/grpccloudprovider.CloudProviderService/Cleanup"
	CloudProviderService_Refresh_FullMethodName                  = "/grpccloudprovider.CloudProviderService/Refresh"
	CloudProviderService_HasInstance_FullMethodName              = "/grpccloudprovider.CloudProviderService/HasInstance"
)

// CloudProviderServiceClient is the client API for CloudProviderService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CloudProviderServiceClient interface {
	Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectReply, error)
	Name(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*NameReply, error)
	NodeGroups(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*NodeGroupsReply, error)
	NodeGroupForNode(ctx context.Context, in *NodeGroupForNodeRequest, opts ...grpc.CallOption) (*NodeGroupForNodeReply, error)
	Pricing(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*PricingModelReply, error)
	GetAvailableMachineTypes(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*AvailableMachineTypesReply, error)
	NewNodeGroup(ctx context.Context, in *NewNodeGroupRequest, opts ...grpc.CallOption) (*NewNodeGroupReply, error)
	GetResourceLimiter(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*ResourceLimiterReply, error)
	GPULabel(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*GPULabelReply, error)
	GetAvailableGPUTypes(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*GetAvailableGPUTypesReply, error)
	Cleanup(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*CleanupReply, error)
	Refresh(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*RefreshReply, error)
	HasInstance(ctx context.Context, in *HasInstanceRequest, opts ...grpc.CallOption) (*HasInstanceReply, error)
}

type cloudProviderServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCloudProviderServiceClient(cc grpc.ClientConnInterface) CloudProviderServiceClient {
	return &cloudProviderServiceClient{cc}
}

func (c *cloudProviderServiceClient) Connect(ctx context.Context, in *ConnectRequest, opts ...grpc.CallOption) (*ConnectReply, error) {
	out := new(ConnectReply)
	err := c.cc.Invoke(ctx, CloudProviderService_Connect_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) Name(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*NameReply, error) {
	out := new(NameReply)
	err := c.cc.Invoke(ctx, CloudProviderService_Name_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) NodeGroups(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*NodeGroupsReply, error) {
	out := new(NodeGroupsReply)
	err := c.cc.Invoke(ctx, CloudProviderService_NodeGroups_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) NodeGroupForNode(ctx context.Context, in *NodeGroupForNodeRequest, opts ...grpc.CallOption) (*NodeGroupForNodeReply, error) {
	out := new(NodeGroupForNodeReply)
	err := c.cc.Invoke(ctx, CloudProviderService_NodeGroupForNode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) Pricing(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*PricingModelReply, error) {
	out := new(PricingModelReply)
	err := c.cc.Invoke(ctx, CloudProviderService_Pricing_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) GetAvailableMachineTypes(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*AvailableMachineTypesReply, error) {
	out := new(AvailableMachineTypesReply)
	err := c.cc.Invoke(ctx, CloudProviderService_GetAvailableMachineTypes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) NewNodeGroup(ctx context.Context, in *NewNodeGroupRequest, opts ...grpc.CallOption) (*NewNodeGroupReply, error) {
	out := new(NewNodeGroupReply)
	err := c.cc.Invoke(ctx, CloudProviderService_NewNodeGroup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) GetResourceLimiter(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*ResourceLimiterReply, error) {
	out := new(ResourceLimiterReply)
	err := c.cc.Invoke(ctx, CloudProviderService_GetResourceLimiter_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) GPULabel(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*GPULabelReply, error) {
	out := new(GPULabelReply)
	err := c.cc.Invoke(ctx, CloudProviderService_GPULabel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) GetAvailableGPUTypes(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*GetAvailableGPUTypesReply, error) {
	out := new(GetAvailableGPUTypesReply)
	err := c.cc.Invoke(ctx, CloudProviderService_GetAvailableGPUTypes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) Cleanup(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*CleanupReply, error) {
	out := new(CleanupReply)
	err := c.cc.Invoke(ctx, CloudProviderService_Cleanup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) Refresh(ctx context.Context, in *CloudProviderServiceRequest, opts ...grpc.CallOption) (*RefreshReply, error) {
	out := new(RefreshReply)
	err := c.cc.Invoke(ctx, CloudProviderService_Refresh_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cloudProviderServiceClient) HasInstance(ctx context.Context, in *HasInstanceRequest, opts ...grpc.CallOption) (*HasInstanceReply, error) {
	out := new(HasInstanceReply)
	err := c.cc.Invoke(ctx, CloudProviderService_HasInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CloudProviderServiceServer is the server API for CloudProviderService service.
// All implementations must embed UnimplementedCloudProviderServiceServer
// for forward compatibility
type CloudProviderServiceServer interface {
	Connect(context.Context, *ConnectRequest) (*ConnectReply, error)
	Name(context.Context, *CloudProviderServiceRequest) (*NameReply, error)
	NodeGroups(context.Context, *CloudProviderServiceRequest) (*NodeGroupsReply, error)
	NodeGroupForNode(context.Context, *NodeGroupForNodeRequest) (*NodeGroupForNodeReply, error)
	Pricing(context.Context, *CloudProviderServiceRequest) (*PricingModelReply, error)
	GetAvailableMachineTypes(context.Context, *CloudProviderServiceRequest) (*AvailableMachineTypesReply, error)
	NewNodeGroup(context.Context, *NewNodeGroupRequest) (*NewNodeGroupReply, error)
	GetResourceLimiter(context.Context, *CloudProviderServiceRequest) (*ResourceLimiterReply, error)
	GPULabel(context.Context, *CloudProviderServiceRequest) (*GPULabelReply, error)
	GetAvailableGPUTypes(context.Context, *CloudProviderServiceRequest) (*GetAvailableGPUTypesReply, error)
	Cleanup(context.Context, *CloudProviderServiceRequest) (*CleanupReply, error)
	Refresh(context.Context, *CloudProviderServiceRequest) (*RefreshReply, error)
	HasInstance(context.Context, *HasInstanceRequest) (*HasInstanceReply, error)
	mustEmbedUnimplementedCloudProviderServiceServer()
}

// UnimplementedCloudProviderServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCloudProviderServiceServer struct {
}

func (UnimplementedCloudProviderServiceServer) Connect(context.Context, *ConnectRequest) (*ConnectReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Connect not implemented")
}
func (UnimplementedCloudProviderServiceServer) Name(context.Context, *CloudProviderServiceRequest) (*NameReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Name not implemented")
}
func (UnimplementedCloudProviderServiceServer) NodeGroups(context.Context, *CloudProviderServiceRequest) (*NodeGroupsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeGroups not implemented")
}
func (UnimplementedCloudProviderServiceServer) NodeGroupForNode(context.Context, *NodeGroupForNodeRequest) (*NodeGroupForNodeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodeGroupForNode not implemented")
}
func (UnimplementedCloudProviderServiceServer) Pricing(context.Context, *CloudProviderServiceRequest) (*PricingModelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pricing not implemented")
}
func (UnimplementedCloudProviderServiceServer) GetAvailableMachineTypes(context.Context, *CloudProviderServiceRequest) (*AvailableMachineTypesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableMachineTypes not implemented")
}
func (UnimplementedCloudProviderServiceServer) NewNodeGroup(context.Context, *NewNodeGroupRequest) (*NewNodeGroupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewNodeGroup not implemented")
}
func (UnimplementedCloudProviderServiceServer) GetResourceLimiter(context.Context, *CloudProviderServiceRequest) (*ResourceLimiterReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetResourceLimiter not implemented")
}
func (UnimplementedCloudProviderServiceServer) GPULabel(context.Context, *CloudProviderServiceRequest) (*GPULabelReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GPULabel not implemented")
}
func (UnimplementedCloudProviderServiceServer) GetAvailableGPUTypes(context.Context, *CloudProviderServiceRequest) (*GetAvailableGPUTypesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableGPUTypes not implemented")
}
func (UnimplementedCloudProviderServiceServer) Cleanup(context.Context, *CloudProviderServiceRequest) (*CleanupReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cleanup not implemented")
}
func (UnimplementedCloudProviderServiceServer) Refresh(context.Context, *CloudProviderServiceRequest) (*RefreshReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (UnimplementedCloudProviderServiceServer) HasInstance(context.Context, *HasInstanceRequest) (*HasInstanceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HasInstance not implemented")
}
func (UnimplementedCloudProviderServiceServer) mustEmbedUnimplementedCloudProviderServiceServer() {}

// UnsafeCloudProviderServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CloudProviderServiceServer will
// result in compilation errors.
type UnsafeCloudProviderServiceServer interface {
	mustEmbedUnimplementedCloudProviderServiceServer()
}

func RegisterCloudProviderServiceServer(s grpc.ServiceRegistrar, srv CloudProviderServiceServer) {
	s.RegisterService(&CloudProviderService_ServiceDesc, srv)
}

func _CloudProviderService_Connect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).Connect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_Connect_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).Connect(ctx, req.(*ConnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_Name_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).Name(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_Name_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).Name(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_NodeGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).NodeGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_NodeGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).NodeGroups(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_NodeGroupForNode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupForNodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).NodeGroupForNode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_NodeGroupForNode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).NodeGroupForNode(ctx, req.(*NodeGroupForNodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_Pricing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).Pricing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_Pricing_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).Pricing(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_GetAvailableMachineTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).GetAvailableMachineTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_GetAvailableMachineTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).GetAvailableMachineTypes(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_NewNodeGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NewNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).NewNodeGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_NewNodeGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).NewNodeGroup(ctx, req.(*NewNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_GetResourceLimiter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).GetResourceLimiter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_GetResourceLimiter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).GetResourceLimiter(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_GPULabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).GPULabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_GPULabel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).GPULabel(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_GetAvailableGPUTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).GetAvailableGPUTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_GetAvailableGPUTypes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).GetAvailableGPUTypes(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_Cleanup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).Cleanup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_Cleanup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).Cleanup(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloudProviderServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_Refresh_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).Refresh(ctx, req.(*CloudProviderServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CloudProviderService_HasInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HasInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CloudProviderServiceServer).HasInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CloudProviderService_HasInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CloudProviderServiceServer).HasInstance(ctx, req.(*HasInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CloudProviderService_ServiceDesc is the grpc.ServiceDesc for CloudProviderService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CloudProviderService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpccloudprovider.CloudProviderService",
	HandlerType: (*CloudProviderServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Connect",
			Handler:    _CloudProviderService_Connect_Handler,
		},
		{
			MethodName: "Name",
			Handler:    _CloudProviderService_Name_Handler,
		},
		{
			MethodName: "NodeGroups",
			Handler:    _CloudProviderService_NodeGroups_Handler,
		},
		{
			MethodName: "NodeGroupForNode",
			Handler:    _CloudProviderService_NodeGroupForNode_Handler,
		},
		{
			MethodName: "Pricing",
			Handler:    _CloudProviderService_Pricing_Handler,
		},
		{
			MethodName: "GetAvailableMachineTypes",
			Handler:    _CloudProviderService_GetAvailableMachineTypes_Handler,
		},
		{
			MethodName: "NewNodeGroup",
			Handler:    _CloudProviderService_NewNodeGroup_Handler,
		},
		{
			MethodName: "GetResourceLimiter",
			Handler:    _CloudProviderService_GetResourceLimiter_Handler,
		},
		{
			MethodName: "GPULabel",
			Handler:    _CloudProviderService_GPULabel_Handler,
		},
		{
			MethodName: "GetAvailableGPUTypes",
			Handler:    _CloudProviderService_GetAvailableGPUTypes_Handler,
		},
		{
			MethodName: "Cleanup",
			Handler:    _CloudProviderService_Cleanup_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _CloudProviderService_Refresh_Handler,
		},
		{
			MethodName: "HasInstance",
			Handler:    _CloudProviderService_HasInstance_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

const (
	NodeGroupService_MaxSize_FullMethodName            = "/grpccloudprovider.NodeGroupService/MaxSize"
	NodeGroupService_MinSize_FullMethodName            = "/grpccloudprovider.NodeGroupService/MinSize"
	NodeGroupService_TargetSize_FullMethodName         = "/grpccloudprovider.NodeGroupService/TargetSize"
	NodeGroupService_IncreaseSize_FullMethodName       = "/grpccloudprovider.NodeGroupService/IncreaseSize"
	NodeGroupService_DeleteNodes_FullMethodName        = "/grpccloudprovider.NodeGroupService/DeleteNodes"
	NodeGroupService_DecreaseTargetSize_FullMethodName = "/grpccloudprovider.NodeGroupService/DecreaseTargetSize"
	NodeGroupService_Id_FullMethodName                 = "/grpccloudprovider.NodeGroupService/Id"
	NodeGroupService_Debug_FullMethodName              = "/grpccloudprovider.NodeGroupService/Debug"
	NodeGroupService_Nodes_FullMethodName              = "/grpccloudprovider.NodeGroupService/Nodes"
	NodeGroupService_TemplateNodeInfo_FullMethodName   = "/grpccloudprovider.NodeGroupService/TemplateNodeInfo"
	NodeGroupService_Exist_FullMethodName              = "/grpccloudprovider.NodeGroupService/Exist"
	NodeGroupService_Create_FullMethodName             = "/grpccloudprovider.NodeGroupService/Create"
	NodeGroupService_Delete_FullMethodName             = "/grpccloudprovider.NodeGroupService/Delete"
	NodeGroupService_Autoprovisioned_FullMethodName    = "/grpccloudprovider.NodeGroupService/Autoprovisioned"
	NodeGroupService_Belongs_FullMethodName            = "/grpccloudprovider.NodeGroupService/Belongs"
	NodeGroupService_GetOptions_FullMethodName         = "/grpccloudprovider.NodeGroupService/GetOptions"
)

// NodeGroupServiceClient is the client API for NodeGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeGroupServiceClient interface {
	MaxSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*MaxSizeReply, error)
	MinSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*MinSizeReply, error)
	TargetSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*TargetSizeReply, error)
	IncreaseSize(ctx context.Context, in *IncreaseSizeRequest, opts ...grpc.CallOption) (*IncreaseSizeReply, error)
	DeleteNodes(ctx context.Context, in *DeleteNodesRequest, opts ...grpc.CallOption) (*DeleteNodesReply, error)
	DecreaseTargetSize(ctx context.Context, in *DecreaseTargetSizeRequest, opts ...grpc.CallOption) (*DecreaseTargetSizeReply, error)
	Id(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*IdReply, error)
	Debug(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*DebugReply, error)
	Nodes(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*NodesReply, error)
	TemplateNodeInfo(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*TemplateNodeInfoReply, error)
	Exist(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*ExistReply, error)
	Create(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*CreateReply, error)
	Delete(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*DeleteReply, error)
	Autoprovisioned(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*AutoprovisionedReply, error)
	Belongs(ctx context.Context, in *BelongsRequest, opts ...grpc.CallOption) (*BelongsReply, error)
	GetOptions(ctx context.Context, in *GetOptionsRequest, opts ...grpc.CallOption) (*GetOptionsReply, error)
}

type nodeGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeGroupServiceClient(cc grpc.ClientConnInterface) NodeGroupServiceClient {
	return &nodeGroupServiceClient{cc}
}

func (c *nodeGroupServiceClient) MaxSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*MaxSizeReply, error) {
	out := new(MaxSizeReply)
	err := c.cc.Invoke(ctx, NodeGroupService_MaxSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) MinSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*MinSizeReply, error) {
	out := new(MinSizeReply)
	err := c.cc.Invoke(ctx, NodeGroupService_MinSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) TargetSize(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*TargetSizeReply, error) {
	out := new(TargetSizeReply)
	err := c.cc.Invoke(ctx, NodeGroupService_TargetSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) IncreaseSize(ctx context.Context, in *IncreaseSizeRequest, opts ...grpc.CallOption) (*IncreaseSizeReply, error) {
	out := new(IncreaseSizeReply)
	err := c.cc.Invoke(ctx, NodeGroupService_IncreaseSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) DeleteNodes(ctx context.Context, in *DeleteNodesRequest, opts ...grpc.CallOption) (*DeleteNodesReply, error) {
	out := new(DeleteNodesReply)
	err := c.cc.Invoke(ctx, NodeGroupService_DeleteNodes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) DecreaseTargetSize(ctx context.Context, in *DecreaseTargetSizeRequest, opts ...grpc.CallOption) (*DecreaseTargetSizeReply, error) {
	out := new(DecreaseTargetSizeReply)
	err := c.cc.Invoke(ctx, NodeGroupService_DecreaseTargetSize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Id(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*IdReply, error) {
	out := new(IdReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Id_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Debug(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*DebugReply, error) {
	out := new(DebugReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Debug_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Nodes(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Nodes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) TemplateNodeInfo(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*TemplateNodeInfoReply, error) {
	out := new(TemplateNodeInfoReply)
	err := c.cc.Invoke(ctx, NodeGroupService_TemplateNodeInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Exist(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*ExistReply, error) {
	out := new(ExistReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Exist_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Create(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*CreateReply, error) {
	out := new(CreateReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Create_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Delete(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*DeleteReply, error) {
	out := new(DeleteReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Autoprovisioned(ctx context.Context, in *NodeGroupServiceRequest, opts ...grpc.CallOption) (*AutoprovisionedReply, error) {
	out := new(AutoprovisionedReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Autoprovisioned_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) Belongs(ctx context.Context, in *BelongsRequest, opts ...grpc.CallOption) (*BelongsReply, error) {
	out := new(BelongsReply)
	err := c.cc.Invoke(ctx, NodeGroupService_Belongs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupServiceClient) GetOptions(ctx context.Context, in *GetOptionsRequest, opts ...grpc.CallOption) (*GetOptionsReply, error) {
	out := new(GetOptionsReply)
	err := c.cc.Invoke(ctx, NodeGroupService_GetOptions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeGroupServiceServer is the server API for NodeGroupService service.
// All implementations must embed UnimplementedNodeGroupServiceServer
// for forward compatibility
type NodeGroupServiceServer interface {
	MaxSize(context.Context, *NodeGroupServiceRequest) (*MaxSizeReply, error)
	MinSize(context.Context, *NodeGroupServiceRequest) (*MinSizeReply, error)
	TargetSize(context.Context, *NodeGroupServiceRequest) (*TargetSizeReply, error)
	IncreaseSize(context.Context, *IncreaseSizeRequest) (*IncreaseSizeReply, error)
	DeleteNodes(context.Context, *DeleteNodesRequest) (*DeleteNodesReply, error)
	DecreaseTargetSize(context.Context, *DecreaseTargetSizeRequest) (*DecreaseTargetSizeReply, error)
	Id(context.Context, *NodeGroupServiceRequest) (*IdReply, error)
	Debug(context.Context, *NodeGroupServiceRequest) (*DebugReply, error)
	Nodes(context.Context, *NodeGroupServiceRequest) (*NodesReply, error)
	TemplateNodeInfo(context.Context, *NodeGroupServiceRequest) (*TemplateNodeInfoReply, error)
	Exist(context.Context, *NodeGroupServiceRequest) (*ExistReply, error)
	Create(context.Context, *NodeGroupServiceRequest) (*CreateReply, error)
	Delete(context.Context, *NodeGroupServiceRequest) (*DeleteReply, error)
	Autoprovisioned(context.Context, *NodeGroupServiceRequest) (*AutoprovisionedReply, error)
	Belongs(context.Context, *BelongsRequest) (*BelongsReply, error)
	GetOptions(context.Context, *GetOptionsRequest) (*GetOptionsReply, error)
	mustEmbedUnimplementedNodeGroupServiceServer()
}

// UnimplementedNodeGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedNodeGroupServiceServer struct {
}

func (UnimplementedNodeGroupServiceServer) MaxSize(context.Context, *NodeGroupServiceRequest) (*MaxSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MaxSize not implemented")
}
func (UnimplementedNodeGroupServiceServer) MinSize(context.Context, *NodeGroupServiceRequest) (*MinSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MinSize not implemented")
}
func (UnimplementedNodeGroupServiceServer) TargetSize(context.Context, *NodeGroupServiceRequest) (*TargetSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TargetSize not implemented")
}
func (UnimplementedNodeGroupServiceServer) IncreaseSize(context.Context, *IncreaseSizeRequest) (*IncreaseSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncreaseSize not implemented")
}
func (UnimplementedNodeGroupServiceServer) DeleteNodes(context.Context, *DeleteNodesRequest) (*DeleteNodesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodes not implemented")
}
func (UnimplementedNodeGroupServiceServer) DecreaseTargetSize(context.Context, *DecreaseTargetSizeRequest) (*DecreaseTargetSizeReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DecreaseTargetSize not implemented")
}
func (UnimplementedNodeGroupServiceServer) Id(context.Context, *NodeGroupServiceRequest) (*IdReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Id not implemented")
}
func (UnimplementedNodeGroupServiceServer) Debug(context.Context, *NodeGroupServiceRequest) (*DebugReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Debug not implemented")
}
func (UnimplementedNodeGroupServiceServer) Nodes(context.Context, *NodeGroupServiceRequest) (*NodesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Nodes not implemented")
}
func (UnimplementedNodeGroupServiceServer) TemplateNodeInfo(context.Context, *NodeGroupServiceRequest) (*TemplateNodeInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TemplateNodeInfo not implemented")
}
func (UnimplementedNodeGroupServiceServer) Exist(context.Context, *NodeGroupServiceRequest) (*ExistReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exist not implemented")
}
func (UnimplementedNodeGroupServiceServer) Create(context.Context, *NodeGroupServiceRequest) (*CreateReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedNodeGroupServiceServer) Delete(context.Context, *NodeGroupServiceRequest) (*DeleteReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNodeGroupServiceServer) Autoprovisioned(context.Context, *NodeGroupServiceRequest) (*AutoprovisionedReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Autoprovisioned not implemented")
}
func (UnimplementedNodeGroupServiceServer) Belongs(context.Context, *BelongsRequest) (*BelongsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Belongs not implemented")
}
func (UnimplementedNodeGroupServiceServer) GetOptions(context.Context, *GetOptionsRequest) (*GetOptionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOptions not implemented")
}
func (UnimplementedNodeGroupServiceServer) mustEmbedUnimplementedNodeGroupServiceServer() {}

// UnsafeNodeGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeGroupServiceServer will
// result in compilation errors.
type UnsafeNodeGroupServiceServer interface {
	mustEmbedUnimplementedNodeGroupServiceServer()
}

func RegisterNodeGroupServiceServer(s grpc.ServiceRegistrar, srv NodeGroupServiceServer) {
	s.RegisterService(&NodeGroupService_ServiceDesc, srv)
}

func _NodeGroupService_MaxSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).MaxSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_MaxSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).MaxSize(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_MinSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).MinSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_MinSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).MinSize(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_TargetSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).TargetSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_TargetSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).TargetSize(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_IncreaseSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncreaseSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).IncreaseSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_IncreaseSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).IncreaseSize(ctx, req.(*IncreaseSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_DeleteNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).DeleteNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_DeleteNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).DeleteNodes(ctx, req.(*DeleteNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_DecreaseTargetSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecreaseTargetSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).DecreaseTargetSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_DecreaseTargetSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).DecreaseTargetSize(ctx, req.(*DecreaseTargetSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Id_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Id(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Id_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Id(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Debug_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Debug(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Debug_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Debug(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Nodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Nodes(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_TemplateNodeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).TemplateNodeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_TemplateNodeInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).TemplateNodeInfo(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Exist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Exist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Exist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Exist(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Create_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Create(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Delete(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Autoprovisioned_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeGroupServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Autoprovisioned(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Autoprovisioned_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Autoprovisioned(ctx, req.(*NodeGroupServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_Belongs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BelongsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).Belongs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_Belongs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).Belongs(ctx, req.(*BelongsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroupService_GetOptions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOptionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupServiceServer).GetOptions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroupService_GetOptions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupServiceServer).GetOptions(ctx, req.(*GetOptionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeGroupService_ServiceDesc is the grpc.ServiceDesc for NodeGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpccloudprovider.NodeGroupService",
	HandlerType: (*NodeGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "MaxSize",
			Handler:    _NodeGroupService_MaxSize_Handler,
		},
		{
			MethodName: "MinSize",
			Handler:    _NodeGroupService_MinSize_Handler,
		},
		{
			MethodName: "TargetSize",
			Handler:    _NodeGroupService_TargetSize_Handler,
		},
		{
			MethodName: "IncreaseSize",
			Handler:    _NodeGroupService_IncreaseSize_Handler,
		},
		{
			MethodName: "DeleteNodes",
			Handler:    _NodeGroupService_DeleteNodes_Handler,
		},
		{
			MethodName: "DecreaseTargetSize",
			Handler:    _NodeGroupService_DecreaseTargetSize_Handler,
		},
		{
			MethodName: "Id",
			Handler:    _NodeGroupService_Id_Handler,
		},
		{
			MethodName: "Debug",
			Handler:    _NodeGroupService_Debug_Handler,
		},
		{
			MethodName: "Nodes",
			Handler:    _NodeGroupService_Nodes_Handler,
		},
		{
			MethodName: "TemplateNodeInfo",
			Handler:    _NodeGroupService_TemplateNodeInfo_Handler,
		},
		{
			MethodName: "Exist",
			Handler:    _NodeGroupService_Exist_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _NodeGroupService_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NodeGroupService_Delete_Handler,
		},
		{
			MethodName: "Autoprovisioned",
			Handler:    _NodeGroupService_Autoprovisioned_Handler,
		},
		{
			MethodName: "Belongs",
			Handler:    _NodeGroupService_Belongs_Handler,
		},
		{
			MethodName: "GetOptions",
			Handler:    _NodeGroupService_GetOptions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}

const (
	PricingModelService_NodePrice_FullMethodName = "/grpccloudprovider.PricingModelService/NodePrice"
	PricingModelService_PodPrice_FullMethodName  = "/grpccloudprovider.PricingModelService/PodPrice"
)

// PricingModelServiceClient is the client API for PricingModelService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PricingModelServiceClient interface {
	NodePrice(ctx context.Context, in *NodePriceRequest, opts ...grpc.CallOption) (*NodePriceReply, error)
	PodPrice(ctx context.Context, in *PodPriceRequest, opts ...grpc.CallOption) (*PodPriceReply, error)
}

type pricingModelServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPricingModelServiceClient(cc grpc.ClientConnInterface) PricingModelServiceClient {
	return &pricingModelServiceClient{cc}
}

func (c *pricingModelServiceClient) NodePrice(ctx context.Context, in *NodePriceRequest, opts ...grpc.CallOption) (*NodePriceReply, error) {
	out := new(NodePriceReply)
	err := c.cc.Invoke(ctx, PricingModelService_NodePrice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *pricingModelServiceClient) PodPrice(ctx context.Context, in *PodPriceRequest, opts ...grpc.CallOption) (*PodPriceReply, error) {
	out := new(PodPriceReply)
	err := c.cc.Invoke(ctx, PricingModelService_PodPrice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PricingModelServiceServer is the server API for PricingModelService service.
// All implementations must embed UnimplementedPricingModelServiceServer
// for forward compatibility
type PricingModelServiceServer interface {
	NodePrice(context.Context, *NodePriceRequest) (*NodePriceReply, error)
	PodPrice(context.Context, *PodPriceRequest) (*PodPriceReply, error)
	mustEmbedUnimplementedPricingModelServiceServer()
}

// UnimplementedPricingModelServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPricingModelServiceServer struct {
}

func (UnimplementedPricingModelServiceServer) NodePrice(context.Context, *NodePriceRequest) (*NodePriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NodePrice not implemented")
}
func (UnimplementedPricingModelServiceServer) PodPrice(context.Context, *PodPriceRequest) (*PodPriceReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PodPrice not implemented")
}
func (UnimplementedPricingModelServiceServer) mustEmbedUnimplementedPricingModelServiceServer() {}

// UnsafePricingModelServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PricingModelServiceServer will
// result in compilation errors.
type UnsafePricingModelServiceServer interface {
	mustEmbedUnimplementedPricingModelServiceServer()
}

func RegisterPricingModelServiceServer(s grpc.ServiceRegistrar, srv PricingModelServiceServer) {
	s.RegisterService(&PricingModelService_ServiceDesc, srv)
}

func _PricingModelService_NodePrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodePriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PricingModelServiceServer).NodePrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PricingModelService_NodePrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PricingModelServiceServer).NodePrice(ctx, req.(*NodePriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PricingModelService_PodPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PodPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PricingModelServiceServer).PodPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PricingModelService_PodPrice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PricingModelServiceServer).PodPrice(ctx, req.(*PodPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PricingModelService_ServiceDesc is the grpc.ServiceDesc for PricingModelService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PricingModelService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "grpccloudprovider.PricingModelService",
	HandlerType: (*PricingModelServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "NodePrice",
			Handler:    _PricingModelService_NodePrice_Handler,
		},
		{
			MethodName: "PodPrice",
			Handler:    _PricingModelService_PodPrice_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "grpc.proto",
}
